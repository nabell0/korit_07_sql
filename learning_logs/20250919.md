1. 다음 중 관계형 데이터베이스 관리 시스템(RDBMS)의 주요 특징으로 볼 수 없는 것은? 

(1) 데이터를 테이블(릴레이션) 형태로 저장한다. 

(2) 데이터 조작을 위해 SQL(Structured Query Language)을 사용한다. 

(3) 데이터 무결성 유지를 위해 무결성 제약 조건을 지원한다. 

(4) 데이터의 중복을 최소화하기 위해 비정규화(Denormalization) 원칙을 따른다.

 

2. 데이터베이스의 내부 데이터를 조작하기 위한 기능에 해당하는 SQL의 종류는? 

(1) DDL (Data Definition Language) 

(2) DML (Data Manipulation Language) 

(3) DCL (Data Control Language) 

(4) TCL (Transaction Control Language)

 

3. 테이블의 구조를 정의하고 관리하는 SQL 명령어에 해당하는 것은? 

(1) SELECT 

(2) INSERT 

(3) UPDATE 

(4) CREATE

 

4. 다음 중 데이터베이스 보안과 사용자 권한 관리에 주로 사용되는 SQL 명령어는? 

(1) GRANT, REVOKE 

(2) COMMIT, ROLLBACK 

(3) TRUNCATE, DROP 

(4) INSERT, DELETE

 

5. SQL문의 실행 순서가 올바르게 나열된 것은? 

(1) SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY 

(2) FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY 

(3) FROM -> WHERE -> SELECT -> GROUP BY -> HAVING -> ORDER BY 

(4) FROM -> SELECT -> WHERE -> GROUP BY -> HAVING -> ORDER BY

 

6. users 테이블에서 country 컬럼의 데이터 중 중복을 제외하고 개수를 세는 올바른 SQL문은? 

(1) SELECT COUNT(country) FROM users; 

(2) SELECT COUNT(*) FROM users; 

(3) SELECT COUNT(DISTINCT country) FROM users; 

(4) SELECT COUNT(ALL country) FROM users;

 

7. products 테이블에서 price 컬럼의 평균값을 소수점 둘째 자리까지 반올림하여 출력하는 올바른 SQL문은? 

(1) SELECT ROUND(price) FROM products; 

(2) SELECT ROUND(AVG(price), 2) FROM products; 

(3) SELECT AVG(ROUND(price)) FROM products; 

(4) SELECT ROUND(AVG(price), 3) FROM products;

 

8. users 테이블에서 created_at 컬럼의 값이 '2011-01'로 시작하는 모든 회원을 조회하는 SQL문은? 

(1) SELECT * FROM users WHERE created_at = '2011-01%'; 

(2) SELECT * FROM users WHERE created_at LIKE '2011-01%'; 

(3) SELECT * FROM users WHERE created_at IN ('2011-01'); 

(4) SELECT * FROM users WHERE SUBSTR(created_at, 1, 7) = '2011-01';

 

9. products 테이블에서 price가 10 이상 30 이하인 제품을 조회할 때, 가장 효율적인 WHERE 절은? 

(1) WHERE price >= 10 AND price <= 30 

(2) WHERE price BETWEEN 10 AND 30 

(3) WHERE price = 10 OR price = 30 

(4) WHERE price > 9 AND price < 31

 

10. users 테이블과 orders 테이블을 user_id를 기준으로 결합하여, 두 테이블 모두에 존재하는 데이터만 출력하는 JOIN 유형은? 

(1) INNER JOIN 

(2) LEFT JOIN 

(3) RIGHT JOIN 

(4) CROSS JOIN

 

11. users 테이블의 모든 데이터와, orders 테이블에 매칭되는 데이터가 있을 경우에만 orders의 데이터를 함께 출력하는 JOIN 유형은? 

(1) RIGHT JOIN 

(2) INNER JOIN 

(3) LEFT JOIN 

(4) CROSS JOIN

 

12. WHERE 절에 사용할 수 있는 집계 함수는? 

(1) COUNT() 

(2) SUM() 

(3) AVG() 

(4) 모두 사용할 수 없다.

 

13. GROUP BY 절에 대한 설명으로 올바른 것은? 

(1) SELECT 절보다 나중에 실행되어 집계 함수 결과에 조건을 건다. 

(2) WHERE 절보다 먼저 실행되어 테이블 데이터를 그룹으로 묶는다. 

(3) FROM 절보다 먼저 실행되어 필터링을 수행한다. 

(4) ORDER BY 절보다 나중에 실행되어 최종 정렬을 담당한다.

 

14. 두 쿼리의 결과 집합을 위아래로 결합할 때, 중복된 행을 제거하는 키워드는? 

(1) JOIN (2) UNION (3) UNION ALL (4) INTERSECT

 

15. SELECT 절에서 단일 값을 반환하는 서브쿼리를 사용하여 새로운 컬럼을 추가하는 쿼리 유형은? 

(1) Inline View (2) Scalar Subquery (3) WHERE Subquery (4) Correlated Subquery

 

16. FROM 절에서 서브쿼리 결과물을 마치 테이블처럼 사용하는 쿼리 유형은? 

(1) Inline View (2) Scalar Subquery (3) WHERE Subquery (4) Correlated Subquery

 

17. products 테이블에 새로운 컬럼 category를 VARCHAR(50) 타입으로 추가하는 DDL문은? 

(1) CREATE TABLE products ADD category VARCHAR(50); 

(2) ALTER TABLE products ADD COLUMN category VARCHAR(50); 

(3) UPDATE TABLE products ADD category VARCHAR(50); 

(4) INSERT INTO products ADD category VARCHAR(50);

 

18. products 테이블에서 id가 1인 제품의 price를 20으로 변경하는 DML문은? 

(1) INSERT INTO products SET price = 20 WHERE id = 1; 

(2) UPDATE products SET price = 20 WHERE id = 1; 

(3) DELETE FROM products SET price = 20 WHERE id = 1; 

(4) ALTER TABLE products CHANGE price = 20 WHERE id = 1;

19. users 테이블에서 city가 'Seoul'인 모든 행을 삭제하는 DML문은? 

(1) ALTER TABLE users DROP WHERE city = 'Seoul'; 

(2) UPDATE users SET status = 'deleted' WHERE city = 'Seoul'; 

(3) DELETE FROM users WHERE city = 'Seoul'; 

(4) TRUNCATE TABLE users WHERE city = 'Seoul';

 

20다음 중 DCL(Data Control Language)에 해당하지 않는 명령어는? 

(1) GRANT (2) REVOKE (3) CREATE USER (4) COMMIT

 

21. users 테이블에서 country가 'Korea'인 회원이 마케팅 수신 동의(is_marketing_agree = 1)를 한 회원 수를 세는 올바른 쿼리는? 

(1) SELECT COUNT(*) FROM users WHERE country = 'Korea'; 

(2) SELECT COUNT(is_marketing_agree) FROM users WHERE is_marketing_agree = 1; 

(3) SELECT COUNT(*) FROM users WHERE country = 'Korea' AND is_marketing_agree = 1; 

(4) SELECT COUNT(*) FROM users GROUP BY country, is_marketing_agree;

 

22. orders 테이블에서 주문 날짜(order_date)가 '2015년 12월'에 해당하는 주문을 모두 조회하는 쿼리는? 

(1) SELECT * FROM orders WHERE order_date LIKE '2015-12%'; 

(2) SELECT * FROM orders WHERE order_date = '2015-12'; 

(3) SELECT * FROM orders WHERE SUBSTR(order_date, 1, 7) = '2015-12'; 

(4) SELECT * FROM orders WHERE order_date BETWEEN '2015-12-01' AND '2015-12-31';

 

23. users 테이블에서 country가 'UK'거나 'USA'인 회원의 수를 조회하는 쿼리는? 

(1) SELECT COUNT(*) FROM users WHERE country = 'UK' AND country = 'USA'; 

(2) SELECT COUNT(*) FROM users WHERE country IN ('UK', 'USA'); 

(3) SELECT COUNT(*) FROM users WHERE country LIKE 'UK' OR 'USA'; 

(4) SELECT COUNT(*) FROM users WHERE country = 'UK' OR 'USA';

 

24. products 테이블에서 price가 가장 비싼 제품의 이름을 조회하는 쿼리는? 

(1) SELECT name FROM products ORDER BY price DESC; 

(2) SELECT name FROM products WHERE price = MAX(price); 

(3) SELECT name FROM products WHERE price = (SELECT MAX(price) FROM products); 

(4) SELECT name FROM products WHERE price >= (SELECT MAX(price) FROM products);

 

25. users 테이블에서 city 컬럼을 기준으로 그룹화하여, city별 회원 수를 구하는 쿼리는? 

(1) SELECT COUNT(*) FROM users GROUP BY city; 

(2) SELECT city, COUNT(id) FROM users; 

(3) SELECT city, COUNT(id) FROM users GROUP BY city; 

(4) SELECT city, COUNT(id) FROM users ORDER BY city;

 

26. orders 테이블과 orderdetails 테이블을 결합하여, orders에는 있지만 orderdetails에 없는 주문 정보를 찾으려면 어떤 JOIN과 조건이 필요한가? 

(1) INNER JOIN과 WHERE 절에 od.order_id IS NULL 

(2) LEFT JOIN과 WHERE 절에 od.order_id IS NULL 

(3) RIGHT JOIN과 WHERE 절에 o.id IS NULL 

(4) CROSS JOIN과 WHERE 절에 od.order_id IS NULL

 

27. users 테이블의 모든 행과 orders 테이블의 모든 행을 곱하여 가능한 모든 조합을 출력하는 JOIN은?

 (1) INNER JOIN (2) LEFT JOIN (3) RIGHT JOIN (4) CROSS JOIN

 

28. orders 테이블에서 order_date가 '2016-01-01'부터 '2016-01-31'까지인 주문 건수와 order_date가 '2015-08-01'부터 '2015-08-31'까지인 주문 건수를 각각 구하여 위아래로 합치는 쿼리는? 

(1) SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2016-01-01' AND '2016-01-31' JOIN SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2015-08-01' AND '2015-08-31'; 

(2) SELECT COUNT(*) FROM orders WHERE order_date LIKE '2016-01%'; JOIN SELECT COUNT(*) FROM orders WHERE order_date LIKE '2015-08%'; 

(3) (SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2016-01-01' AND '2016-01-31') UNION ALL (SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2015-08-01' AND '2015-08-31');

(4) (SELECT COUNT(*) FROM orders WHERE order_date LIKE '2016-01%') UNION (SELECT COUNT(*) FROM orders WHERE order_date LIKE '2015-08%');

 

29. GROUP BY를 사용하여 그룹별로 집계한 결과에 조건을 설정하고 싶을 때 사용해야 하는 절은? 

(1) WHERE (2) ON (3) HAVING (4) ORDER BY

 

30. 다음 중 데이터베이스에서 ALTER TABLE을 사용하여 수행할 수 없는 작업은? 

(1) 기존 컬럼의 이름을 변경하는 것 (2) 새로운 컬럼을 추가하는 것 (3) 기존 테이블의 이름을 변경하는 것 (4) 특정 행의 데이터를 삭제하는 것